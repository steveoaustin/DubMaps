package temp332;

import java.util.NoSuchElementException;

import cse332.exceptions.NotYetImplementedException;
import cse332.interfaces.worklists.FIFOWorkList;

/**
 * See cse332/interfaces/worklists/FIFOWorkList.java
 * for method specifications.
 */
public class ListFIFOQueue<E> extends FIFOWorkList<E> {
	private int size;
	private Node<E> head; // "front" of the queue
	private Node<E> tail; // "back"  of the queue
	
	/**
	 * Constructs a new, empty ListFIFOQueue
	 */
    public ListFIFOQueue() {
    	size = 0;
    	head = null;
    	tail = null; 
    }

    @Override
    /**
     * Adds work to the back of the queue
     * @throws IllegalArgumentException: indicates work is null
     */
    public void add(E work) {
    	if (work == null) {
    		throw new IllegalArgumentException("cannot add null work");
    	}
    	// add to empty queue
    	if (size == 0) {
    		tail = new Node<E>(work, null);
    		head = tail;
    		size++;
    	}
    	// add to multi-element queue
    	else if (size > 0) {
    		Node<E> temp = new Node<E>(work, null);
    		tail.next = temp;
    		tail = temp;
    		size++;
    	}
    }

    @Override
    /**
     * Returns the work stored at the front of the queue, or null if empty
     * @return The first work item in the queue
     * @throws NoSuchElementException: indicates the queue is empty
     */
    public E peek() {
    	if (size == 0) {
    		throw new NoSuchElementException("the queue is empty");
    	} else {
    		return head.data;
    	}
    }

    @Override
    /**
     * Removes the queue's first element and returns its work, or null if empty
     * @return The first work item in the queue
     * @throws NoSuchElementException: indicates the queue is empty
     */
    public E next() {
    	if (size == 0) {
    		throw new NoSuchElementException("the queue is empty");
    	} 
    	E data = head.data;
    	if (size == 1) {
    		head = null;
    		tail = null;
    		size--;    		
    		return data;
    	} else {
    		head = head.next;
    		size--;
    		return data;
    	}
    }

    @Override
    /**
     * Returns the number of elements in the queue
     * @return the size of the queue
     */
    public int size() {
    	return size;
    }

    @Override
    /**
     * Clears every element from the queue
     */
    public void clear() {
    	size = 0;
    	head = null;
    	tail = null;
    }
    
    /*
     * private inner node class; each node represents a node in a linked list
     */
    private class Node<E> {
    	public E data;
    	public Node<E> next;
    	
    	public Node(E data, Node<E> next) {
    		this.data = data;
    		this.next = next;
    	}
    }
}
